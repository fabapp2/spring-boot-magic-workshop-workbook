= Demystifying Spring Boot‚Äôs Auto-Configuration Magic
:app: app
:api: library-api
:auto-config: library-autoconfigure
:stdout: library-stdout
:slf4j: library-slf4j
:starter: library-spring-boot-starter
:author: Fabian Kr√ºger
:author: Moritz Halbritter
:docdate: 2025-04-21
:doctype: article
:toc:

Workshop Spring I/O 2025 - Moritz Halbritter & Fabian Kr√ºger

== Getting Started
- Checkout the workshop project from GitHub

[source,bash]
....
cd ~
git clone https://github.com/fabapp2/spring-boot-magic-workshop.git
cd spring-boot-magic-workshop
git checkout exercise-1
....

== Project Layout
The project has these modules following the https://www.appcontinuum.io/[app continuum layout].

- `{app}` - The **Spring Boot application**
- `{auto-config}` - **Spring Boot Auto-configuration** for the `library`
- `{api}` - **Spring Boot independent** library with `GreetingService` interface
- `{stdout}` - **Spring Boot independent** library implementation logging to stdout
- `{slf4j}` - **Spring Boot independent** library implementation logging with SLF4J
- `{starter}` - A **Spring Boot starter** to make the auto-configuration and all dependencies easily available

== Exercises

=== Prerequisite
_Estimated time: 5 Min._

Start the application in `app` and understand how modules are wired.


=== Exercise 1: Auto Configured Bean
_Estimated time:  ~10 Min._

Make the default `StdOutGreetingService` in `{stdout}` available as an auto-configured Spring bean for Spring Boot applications that rely on `GreetingService`.

==== Learnings
- **How does Spring Boot find auto-configuration classes**
- **How does Spring Boot provide auto-configured beans**
- **How to allow auto-configured beans to be overwritten**

==== Task
. Create an auto-configuration class `com.workshop.magic.config.GreetingAutoConfiguration` in the `{auto-config}` module.

. Add a dependency to `org.springframework.boot:spring-boot-autoconfigure` which brings the `@AutoConfiguration` annotation

. Add a dependency to other required modules. Make them optional which is a best-practice for auto-configurations.

. Annotate `GreetingAutoConfiguration` with `@AutoConfiguration`.

. Annotate the `GreetingAutoConfiguration` with `@ConditionalOnClass(GreetingService.class)` to only process the auto-config when `GreetingService` is on the applications classpath.

. This auto-configuration provides `StdOutGreetingService` as a Spring bean of type `GreetingService`.

. Auto-configuration classes must be declared in a file `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` with their fully qualified name and Spring Boot will create the listed auto-configurations.

. Add a dependency `library-autoconfiguration` to `app` making the auto-configured `GreetingService` available.

. ü§î Starting the application should fail . why?

. To avoid conflicts and allow custom implementations, the `StdOutGreetingService` should only be created when no other bean of type `GreetingService` exists.
This can be achieved by annotating the bean declaration with `@ConditionalOnMissingBean`, which tells Spring Boot to back off when such a bean already exists.

. ‚úÖ Starting the application should now print: _MyGreetingService: Hola SpringIO Barcelona_

. Modify the application to use the `StdOutGreetingService` now.

. ‚úÖ Starting the application should now print: _StdOutGreetingService: Hola SpringIO Barcelona_

NOTE: Auto-configurations must be loaded only by being named in the imports file. Make sure that they are defined in a specific package space and that they are never the target of component scanning. Furthermore, auto-configuration classes should not enable component scanning to find additional components. Specific @Import annotations should be used instead.

==== Detailed Steps

.Detailed Steps
[%collapsible]
====

. Create a new Class `com.workshop.magic.config.GreetingAutoConfiguration` in the `{auto-config}` module.

. Create a new file `src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` in the `{auto-config}` module. (https://docs.spring.io/spring-boot/reference/features/developing-auto-configuration.html#features.developing-auto-configuration.locating-auto-configuration-candidates[see docs])

. Add the fully qualified classname of the `GreetingAutoConfiguration` class to the `.imports` file

. Add the dependency to `com.workshop:library-stdout`.

Add a dependency to other required modules. Make them optional which is a best-practice for auto-configurations.

. Create a new `GreetingService` bean in `GreetingAutoConfiguration` that returns a new instance of `StdOutGreetingService` and initializes it with _"Hola"_ as greeting.

. Annotate the `GreetingAutoConfiguration` with `@AutoConfiguration`.

. Add the dependency to `org.springframework.boot:spring-boot-autoconfigure` to `{auto-config}`


. ‚ùå Starting the application should fail . why?

. Start the application and verify your assumption

. Use the `@ConditionalOnMissingBean` annotation on the `GreetingService` bean method in `GreetingAutoConfiguration` to only load the bean when no other bean of type `GreetingService` exists. (https://docs.spring.io/spring-boot/reference/features/developing-auto-configuration.html#features.developing-auto-configuration.condition-annotations.bean-conditions[see docs])

. Add the dependency to `com.workshop:auto-config` to `app`

. ‚úÖ What will happen when the application starts?

. Start the application and verify your assumption

. Now, remove the `MyGreetingService` class, or comment out/remove the `@Service` annotation on `MyGreetingService`.

. ‚úÖ What will happen when the application starts?

. Start the application and verify your assumption
====

==== Conclusion
Think for a moment, when is this useful and where does Spring Boot use this concept?

.Answer
[%collapsible]
====
Spring Boot's auto-configuration simplifies application development by automatically configuring components based on the dependencies present on the classpath. This feature reduces the need for manual setup, allowing developers to focus on business logic rather than boilerplate code.

For example, adding `spring-boot-starter-data-jpa` and a dependency to the `h2` database driver sets up a `DataSource` for an in-memory database without manual configuration.
====

==== Solution
[source,bash]
....
git checkout -f exercise-2
....

ü•≥ Fantastic, let‚Äôs move on to the next exercise


=== Exercise 2: Custom Spring Boot Starter
You will now package the `{auto-config}` and `{stdout}` modules into a reusable Spring Boot starter.

==== Learnings
- **How do spring-boot-starters work**

==== Task:
. Use the module `{starter}`
. Add dependencies to `{auto-config}` and `{stdout}`
. Replace direct dependencies in the `{app}` module with the new starter
. ‚úÖ Confirm that the app still works as expected and prints the greeting.

==== Conclusion
ü§î Why create a starter? When is it useful in teams or public libraries?

.Answer
[%collapsible]
====
- Clean separation of concerns
- Reusability for teams or public Maven users
- Simplifies integration (just add one dependency)
====



==== Solution
[source,bash]
....
git checkout -f exercise-3
....

ü•≥ Awesome, let‚Äôs move on to the next exercise



=== Exercise 3: Add SLF4J-based GreetingService with Classpath-based Conditional Beans
_Estimated time: ~10‚Äì15 Min._

In this exercise, you will make the existing `LoggerGreetingService` available as an auto-configured bean ‚Äî but only when the corresponding class is on the classpath. You will also adjust the fallback behavior of `StdOutGreetingService` so it is only used when the SLF4J-based implementation is not present.

This pattern mimics common practices in Spring Boot where auto-configured beans adapt to the available classpath.

==== Learnings
- **How to auto-configure beans conditionally based on classpath presence**
- **How to combine `@ConditionalOnClass` and `@ConditionalOnMissingClass`**
- **How to selectively expose features outside the default starter**

==== Task

. In `GreetingAutoConfiguration`, register an additional `GreetingService` bean that returns a `LoggerGreetingService`.

. Annotate this method with:
- `@ConditionalOnClass(LoggerGreetingService.class)` ‚Äî loads only when available
- `@ConditionalOnMissingBean` ‚Äî to allow overriding by users

. Update the existing `StdOutGreetingService` bean:
- Add `@ConditionalOnMissingClass("com.workshop.magic.service.slf4j.LoggerGreetingService")` ‚Äî fallback only if SLF4J is not available

. Ensure the module `{slf4j}` is **not included** in `{starter}`.

. In the `{app}` module, replace the individual module dependencies with:
- `library-spring-boot-starter`
- `library-slf4j`

‚úÖ Start the app: You should see `LoggerGreetingService: Hola SpringIO Barcelona`.

‚úÖ Remove the `library-slf4j` dependency: You should now see `StdOutGreetingService`.

==== Detailed Steps

.Detailed Steps
[%collapsible]
====

. In `GreetingAutoConfiguration.java`, add this bean method:

    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnClass(LoggerGreetingService.class)
    GreetingService slf4jGreetingService() {
        return new LoggerGreetingService();
    }

. In the existing stdOutGreetingService() method, add:

    @ConditionalOnMissingClass("com.workshop.magic.service.slf4j.LoggerGreetingService")

. Make sure the {auto-config} module declares the dependency to {slf4j} with:

    <dependency>
        <groupId>com.workshop</groupId>
        <artifactId>library-slf4j</artifactId>
        <optional>true</optional>
    </dependency>

. In the {starter} module (library-spring-boot-starter), ensure {slf4j} is not added as a dependency. Only {api}, {stdout}, and {auto-config} should be included.

    <dependency>
        <groupId>com.workshop</groupId>
        <artifactId>library-autoconfigure</artifactId>
    </dependency>
    <dependency>
        <groupId>com.workshop</groupId>
        <artifactId>library-api</artifactId>
    </dependency>
    <dependency>
        <groupId>com.workshop</groupId>
        <artifactId>library-stdout</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>

    With:

    <dependency>
        <groupId>com.workshop</groupId>
        <artifactId>library-spring-boot-starter</artifactId>
    </dependency>
    <dependency>
        <groupId>com.workshop</groupId>
        <artifactId>library-slf4j</artifactId>
    </dependency>

. Run the application.

. ‚úÖ You should see LoggerGreetingService output.

. Remove the library-slf4j dependency from the app and rerun.

. ‚úÖ You should see fallback to StdOutGreetingService.
====

==== Conclusion

This pattern of classpath-based behavior is common in real-world Spring Boot libraries. It allows default behavior that can be overridden simply by adding another dependency ‚Äî without requiring configuration or code changes.

.Answer
[%collapsible]

Spring Boot uses classpath detection extensively to toggle features. For example, if Hibernate is on the classpath, JPA support is auto-configured. If it isn‚Äôt, Spring Boot silently skips it. This reduces configuration overhead and provides smart defaults that adapt to the environment.

==== Solution
[source,bash]
‚Ä¶.
git checkout -f exercise-4
‚Ä¶.

ü•≥ Superb, let‚Äôs move on to the next exercise

=== Exercise 4: Conditions Evaluation Report
_Estimated time: ~5 Min._

In this exercise, you'll learn how to leverage Spring Boot's Conditions Evaluation Report to understand why certain auto-configurations are applied or not. This is especially useful when troubleshooting unexpected behavior in your application.

==== Learnings
- **How to enable and interpret the Conditions Evaluation Report**
- **How to identify why certain beans are or aren't loaded**

==== Task

. Enable debug mode in your application to view the Conditions Evaluation Report:
+
[source,properties]
----
debug=true
----
+
This can be added to your `application.properties` file or passed as a command-line argument using `--debug`.

. Start your application. Upon startup, you should see a detailed report in the console that looks like:
+
[source]
----
===========================
CONDITIONS EVALUATION REPORT
===========================

Positive matches:
-----------------
   ...

Negative matches:
-----------------
   ...
----
+
This report lists all auto-configuration classes and the conditions that determined whether they were applied.

. Review the report to understand which configurations were applied and which were not, along with the reasons.

. Use this information to troubleshoot any unexpected behavior or to verify that your custom configurations are being considered appropriately.

==== Conclusion

The Conditions Evaluation Report is a powerful tool for diagnosing configuration issues in Spring Boot applications. By understanding which conditions are met or not, you can gain insights into the auto-configuration process and ensure your application behaves as expected.

==== Solution
[source,bash]
....
git checkout -f exercise-5
....

ü•≥ Great job! Let's proceed to the next exercise.


=== Exercise 5: Property Configuration and @ConditionalOnProperty
_Estimated Time: ~10Min._

==== Learnings
- **How to parametrize auto-configured beans**
- **How to make auto-configured beans depending on properties**

==== Task

. Make the alternative `GreetingService` implementation `LoggerGreetingService` available as auto-configured bean using properties.
. Add a new bean declaration for `LoggerGreetingService` in the auto-configuration class.
. Add a dependency to `{slf4j}` in the `{auto-config}` module.
. Annotate the new bean with a property-based condition to activate it only when `workshop.greeting.type=logger`.
. Annotate the existing bean for `StdOutGreetingService` to act as fallback when the property is `stdout` or not set.
. Provide a configuration class that binds properties with prefix `workshop.greeting`.
. Enable property binding for the configuration class in the auto-configuration class.
. Inject the bound configuration into both beans and pass the greeting text to the constructor.
. Add the following properties in `application.properties`:
    - `workshop.greeting.text`
    - `workshop.greeting.type`
. Start the application and observe which implementation is used.
. Remove or change the `workshop.greeting.type` property and observe the fallback behavior.


==== Conclusion

In this exercise, you learned how to make auto-configured beans dynamic using external properties.
This makes it easy for end users to configure application behavior without touching Java code.

Using `@ConditionalOnProperty`, you can activate specific beans based on the application's configuration, enabling powerful runtime flexibility.

==== Detailed Steps


.Detailed Steps
[%collapsible]
====

. In the `{auto-config}` module, open the `GreetingProperties` class and annotate it with:
+
[source,java]
----
@ConfigurationProperties(prefix = "workshop.greeting")
----

. In the same module, annotate `GreetingAutoConfiguration` with:
+
[source,java]
----
@EnableConfigurationProperties(GreetingProperties.class)
----

. Add the optional dependency to `{slf4j}` in `{auto-config}/pom.xml`.

. In `GreetingAutoConfiguration`, inject `GreetingProperties` into both `GreetingService` bean methods.

. Replace the constructor calls with:
+
[source,java]
----
new StdOutGreetingService(properties.getText())
new LoggerGreetingService(properties.getText())
----

. Annotate the `StdOutGreetingService` bean method with:
+
[source,java]
----
@ConditionalOnProperty(prefix = "workshop.greeting", name = "type", havingValue = "stdout", matchIfMissing = true)
----

. Annotate the `LoggerGreetingService` bean method with:
+
[source,java]
----
@ConditionalOnProperty(prefix = "workshop.greeting", name = "type", havingValue = "logger")
----

. In `application.properties` set the following:
+
[source,properties]
----
workshop.greeting.type=logger
workshop.greeting.text=Gude!
----

. Run the application.

. ‚úÖ You should see: _LoggerGreetingService: Gude SpringIO Barcelona_

. Remove the `workshop.greeting.type` line and restart the app.

. ‚úÖ You should now see: _StdOutGreetingService: Gude SpringIO Barcelona_

TIP: The `LoggerGreetingService` bean will only be created if `library-slf4j` is on the classpath. If not, even `type=logger` will not work.
====


.Answer
[%collapsible]
====
It allows configuring beans provided through auto-configuration and change their behaviour without the need to change the bean declaration itself.
====


==== Solution
[source,bash]
....
git checkout exercise-4
....

ü•≥ Superb, let‚Äôs move on to the next exercise


=== Exercise 6: Using Custom Conditions
_Estimated time:  ~TODO Min._

It is also possible to create custom conditions like the existing `@On...` conditions from Spring Boot.

Let's create a custom condition that checks the system property `my.custom.condition` - just because it's simple.
But imagine you have a more sophisticated custom check here, e.g., infrastructure checks like the https://docs.spring.io/spring-boot/reference/actuator/endpoints.html#actuator.endpoints.kubernetes-probes[Kubernetes probes].
Or you could write a condition which triggers only on 1st of April.

Oh, the possibilities!

==== Learnings
- **How to create your own conditions**
- **How to use that custom condition**

==== Task

* Create a new annotation `@MyCustomCondition`. It must have a `@Target` of `TYPE` and `METHOD` and a `@Retention` of `RUNTIME` (you can also copy that from Spring Boot's `@ConditionalOnProperty`).

* The newly created annotation must be annotated with `@Conditional({OnCustomCondition.class})`.

* A new class, `OnCustomCondition` must be created. It should extend Spring Boot's `SpringBootCondition`.

* The `getMatchOutcome` method must be overriden and should check the `my.custom.condition` system property. Use `ConditionOutcome.match` and `ConditionOutcome.noMatch` to signal if the condition matches or not.

* Modify the `GreetingAutoConfiguration` to use the new `@MyCustomCondition`. A bean of class `BeepGreetingService` should be created if `@MyCustomCondition` matches.

* Test that the application works by setting the system property `my.custom.condition` and verify that the `BeepGreetingService` bean is used.

NOTE: You'll have to set `workshop.greeting.type` to something else than `logger` or `stdout`, because otherwise the `LoggerGreetingService` or `StdOutGreetingService` is also created.

ü§î Also take a look at the conditions evaluation report. Do you see your condition in there?

==== Detailed Steps

.Detailed Steps
[%collapsible]
====

* Create a new annotation in the `{auto-config}` module, called `MyCustomCondition`

* Annotate the annotation with `@Target({ElementType.TYPE, ElementType.METHOD})` and with `@Retention(RetentionPolicy.RUNTIME)`

* Annotate the annotation with `@Conditional({OnCustomCondition.class})`

* Create a class called `OnCustomCondition` and let it extend `SpringBootCondition`

* Implement the `getMatchOutcome` method
** Use `System.getProperty("my.custom.condition")` to read the `my.custom.condition` system property
** If the value of that property is `true`, return `ConditionOutcome.match` to signal that the condition matches
** Otherwise, return `ConditionOutcome.noMatch` to signal that the condition didn't match

* Add a new `@Bean` method to the `GreetingAutoConfiguration` class, call it `beepGreetingService`, its return type is `GreetingService`
** Annotate this new method with `@MyCustomCondition`, `@ConditionalOnMissingBean` and `@ConditionalOnClass(BeepGreetingService.class)`
** Return a new instance of `BeepGreetingService` from that method

* To test the custom condition, you can add `System.setProperty("my.custom.condition", "true");` as first line in the `main` method, or you can set the system properties when starting with your IDE

* You'll also need to add `workshop.greeting.type=none` to your `application.properties`, because otherwise the `LoggerGreetingService` or the `StdOutGreetingService` would be created
====

==== Conclusion
Can you image why it is useful to create custom conditions?

.Answer
[%collapsible]
====
Creating your own conditions is useful if the conditions from Spring Framework and Spring Boot don't fit your needs.
Custom conditions show the power of an extensible framework like the Spring Framework.
There's no "magic" behind the built-in Spring Boot conditions ‚Äî they are built on the same foundations like your custom condition is.

NOTE: You can take a look at the `@Profile` annotation from Spring Framework: The logic is implemented in `ProfileCondition`, and it essentially returns `true` if the profile is activated and `false` if not.
====

==== Solution
[source,bash]
....
git checkout -f exercise-7
....

ü•≥ Phenomenal, let‚Äôs move on to the next exercise


[[testing]]
=== Exercise 7: Testing The Auto-Configuration
_Estimated time:  ~TODO-MH Min._

Create unit tests to ensure that the `GreetingAutoConfiguration` works as expected.

==== Task

- A test class for the `GreetingAutoConfiguration` class must be created.

- A dependency on `org.springframework.boot:spring-boot-starter-test` has to be added in the `auto-config` module.

- Spring Boot's `ApplicationContextRunner` should be used to test the auto-configuration.

- AssertJ assertions should be used to verify that the context contains a `StdOutGreetingService` bean if no property is set.

- The test should assert that the context contains a `StdOutGreetingService` bean if the property `workshop.greeting.type` is set to `stdout`.

- The test should assert that the context contains a `LoggerGreetingService` bean if the property `workshop.greeting.type` is set to `logger`.

- Test test should assert that the context contains `BeepGreetingService` bean if the system property `my.custom.condition` is set to `true`.

- The test should assert that user-defined beans take precedence over the auto-configured `GreetingService` beans ‚Äî essentially testing that `@ConditionalOnMissingBean` works.

==== Conclusion

What value has a unit test for an auto-configuration?

.Answer
[%collapsible]
====
Auto-configurations can contain a lot of conditions, sometimes even custom ones. As this auto-configuration is part of your codebase,
you should also unit-test it to ensure that it behaves as designed, same as the rest of your code.
Spring Boot's `ApplicationContextRunner` makes this easy.
====


==== Detailed Steps

.Detailed Steps
[%collapsible]
====
* Create a class named `GreetingAutoConfigurationTest` in `auto-config/src/test/java` in the package `com.workshop.magic.config`.

* Create a field of type `ApplicationContextRunner`, and use the fluent API to call `withConfiguration` with `AutoConfigurations.of(GreetingAutoConfiguration.class)`.

* Write a test case named `shouldProvideStdOutGreetingServiceByDefault` which uses the `run` method of the `ApplicationContextRunner` field.
** Inside the lambda block of the `run` method, use AssertJ's `assertThat` on the context to call `hasSingleBean` with an `StdOutGreetingService.class` argument.

* Write a test case named `shouldProvideStdOutGreetingServiceWhenPropertyIsSet` which uses the `withPropertyValues` of the `ApplicationContextRunner` field to set the property `workshop.greeting.type` to `stdout`.
** Inside the lambda block of the `run` method, use AssertJ's `assertThat` on the context to call `hasSingleBean` with an `StdOutGreetingService.class` argument.

* Write a test case named `shouldProvideLoggerGreetingServiceWhenPropertyIsSet` which uses the `withPropertyValues` of the `ApplicationContextRunner` field to set the property `workshop.greeting.type` to `logger`.
** Inside the lambda block of the `run` method, use AssertJ's `assertThat` on the context to call `hasSingleBean` with an `LoggerGreetingService.class` argument.

* Write a test case named `shouldProvideBeepGreetingServiceIfSystemPropertyIsSet` which uses `withPropertyValues` of the `ApplicationContextRunner` field to set the property `workshop.greeting.type` to `none`.
** Additionally, it uses the `withSystemProperties` method to set `my.custom.condition` to `true`.
** Inside the lambda block of the `run` method, use AssertJ's `assertThat` on the context to call `hasSingleBean` with an `BeepGreetingService.class` argument.

* Write a test case named `shouldBackOffIfGreetingServiceIsDefinedByUser` which uses the `withBean` method of the `ApplicationContextRunner` field to define a bean of type `GreetingService`.
** Inside the lambda block of the `run` method, use AssertJ's `assertThat` on the context to call `hasSingleBean` with an `GreetingService.class` argument.
====

==== Solution

[source,bash]
....
git checkout -f exercise-8
....

ü•≥ Brilliant, let‚Äôs move on to the next exercise


[[properties-metadata]]
=== Exercise 8: Adding properties metadata
_Estimated time:  ~TODO-MH Min._

Use the Spring Boot configuration processor to generate metadata for your configuration properties.

==== Task

- Add the `org.springframework.boot:spring-boot-configuration-processor` to your project

- Run a build and inspect the `components/{auto-config}/target/classes/META-INF/spring-configuration-metadata.json` file

ü§î Think about why that file could be useful

- The `text` property in `GreetingProperties`  should be renamed to `prefix`, while deprecating the `text` property. Use `@Deprecated` and `@DeprecatedConfigurationProperty` annotations to achieve this

- Run a build and inspect the file `spring-configuration-metadata.json` again

ü§î What has changed? Why could that be useful?

ü§î Open the `application.properties` in your IDE. Do you notice something?

- Add `org.springframework.boot:spring-boot-properties-migrator` to your app

- Start the app and observe the console output

==== Conclusion

What value is provided by that metadata file? Who could use it?

.Answer
[%collapsible]
====
This metadata file is read by IDEs to provide auto-completion for properties.
Additionally, deprecations and their replacement are also recorded in that file, which is also used by IDEs to guide users.
And the `spring-boot-properties-migrator` also uses this file to display deprecations on startup and to provide the automatic mapping from the old property to the new one.
====


.Detailed Steps
[%collapsible]
====

- Add `org.springframework.boot:spring-boot-configuration-processor` to `components/{auto-config}/pom.xml`, with `optional = true`.
- Configure the `maven-compiler-plugin` to include `org.springframework.boot:spring-boot-configuration-processor` as an annotation processor.
You can take a look at https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.5&packaging=jar&jvmVersion=24&groupId=com.example&artifactId=demo&name=demo&description=Demo%20project%20for%20Spring%20Boot&packageName=com.example.demo&dependencies=configuration-processor[the POM file generated by start.spring.io] for an example.
- Run `./mvnw compile` and inspect `components/{auto-config}/target/classes/META-INF/spring-configuration-metadata.json`.
- Replace `private String text;` in the `GreetingProperties` class with `private String prefix`.
- Annotate the `public String getText()` method with `@Deprecated` and with `@DeprecatedConfigurationProperty(replacement = "workshop.greeting.prefix")`.
- Return `this.prefix` from the `getText()` method.
- Assign `this.prefix` in the `setText()` method.
- Add a new getter and setter method for `private String prefix`.
- Run `./mvnw compile` and inspect `components/{auto-config}/target/classes/META-INF/spring-configuration-metadata.json`.
- Add `org.springframework.boot:spring-boot-properties-migrator` with `scope = runtime` to `app/app/pom.xml`.
- Run the application

====

==== Solution
[source,bash]
....
git checkout -f main
....

== Resources

=== Related Talk
https://2025.springio.net/sessions/demystifying-spring-boot-magic/[Demystifying Spring Boot Magic by Patrick Baumgartner]

=== Literature
- https://docs.spring.io/spring-boot/reference/using/auto-configuration.html[Auto-configuration]
- https://docs.spring.io/spring-boot/reference/features/developing-auto-configuration.html#page-title[Creating Your Own Auto-configuration]
- https://docs.spring.io/spring-boot/specification/configuration-metadata/annotation-processor.html[Generating Your Own Metadata by Using the Annotation Processor]
