= Demystifying Spring Bootâ€™s Auto-Configuration Magic
:app:  app
:api: library-api
:auto-config: library-autoconfigure
:stdout: library-stdout
:slf4j: library-slf4j
:starter: library-spring-boot-starter
:author: Fabian KrÃ¼ger
:author: Moritz Halbritter
:docdate: 025-04-21
:doctype: article
:toc:

Workshop SpringIO 2025 - Moritz Halbritter & Fabian KrÃ¼ger

== Getting Started
- Checkout the workshop project from GitHub

[source,bash]
....
cd ~
git clone https://github.com/fabapp2/spring-boot-magic-workshop.git
cd spring-boot-magic-workshop
....

== Project Layout
The project has these modules following the https://www.appcontinuum.io/[app continuum layout].

- `{app}` - The **Spring Boot application**
- `{auto-config}` - **Spring Boot Auto-configuration** for the `library`
- `{api}` - **Spring Boot independant** library with `GreetingService` interface
- `{stdout}` - **Spring Boot independant** library implementation logging to stdout
- `{slf4j}` - **Spring Boot independant** library implementation logging with slf4j
- `{starter}` - The spring-boot-starter module

== Exercises

=== Prerequisite
_Estimated time: 5 Min._

Start the application in `app` and understand how modules are wired.


=== Exercise 1: Auto-Configure A GreetingService Bean
_Estimated time:  ~10 Min._

Make the default `StdOutGreetingService` in `{stdout}` available as auto-configured Spring bean for Spring Boot applications that rely on `GreetingService`.

==== Learnings
- **How does Spring Boot find auto-configuration classes**
- **How does Spring Boot provide auto-configured beans**
- **How to allow auto-configured beans to be overwritten**

==== Task
- Create a auto-configuration class `com.workshop.magic.config.GreetingAutoConfiguration` in the `{auto-config}` module.

- This auto-configuration provides `StdOutGreetingService` as a Spring bean of type `GreetingService`.

- Auto-configuration classes must be declared in a file `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` with their fully qualified name and Spring Boot will create the listed auto-configurations.

- Add a dependency to `org.springframework.boot:spring-boot-autoconfigure` which  brings the `@AutoConfiguration` annotation

- Annotate `GreetingAutoConfiguration` with `@AutoConfiguration`.

ðŸ¤” Starting the application should fail - why?

- To avoid conflicts and allow custom implementations, the `StdOutGreetingService` should only be created when no other bean of type `GreetingService` exists.
This can be achieved by annotating the bean declaration with `@ConditionalOnMissingBean` telling Boot to back off when such a bean already exists.

âœ… Starting the applicaton should now print: _MyGreetingService: Hola SpringIO Barcelona_

- Modify the application to use the `StdOutGreetingService` now.

âœ… Starting the applicaton should now print: _StdOutGreetingService: Hola SpringIO Barcelona_

NOTE: Auto-configurations must be loaded only by being named in the imports file. Make sure that they are defined in a specific package space and that they are never the target of component scanning. Furthermore, auto-configuration classes should not enable component scanning to find additional components. Specific @Import annotations should be used instead.

==== Detailed Steps

.Detailed Steps
[%collapsible]
====

- Create a new Class `com.workshop.magic.config.GreetingAutoConfiguration` in the `{auto-config}` module.

- Create a new file `src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` in the `{auto-config}` module. (https://docs.spring.io/spring-boot/reference/features/developing-auto-configuration.html#features.developing-auto-configuration.locating-auto-configuration-candidates[see docs])

- Add the fully qualified classname of the `GreetingAutoConfigurationÂ´ class to the `.imports` file

- Add the dependency to `com.workshop:library-stdout`.

- Create a new `GreetingService` bean in `GreetingAutoConfiguration` that returns a new instance of `StdOutGreetingService` and initializes it with _"Hola"_ as greeting.

- Add the dependency to `org.springframework.boot:spring-boot-autoconfigure` to `{auto-config}`

- The `GreetingAutoConfiguration` must be annotated with `@AutoConfiguration`.

âŒ Starting the application should fail - why?

- Start the application and verify your assumption

- Use the `@ConditionalOnMissingBean` annotation on the `GreetingService` bean method in `GreetingAutoConfiguration` to only load the bean when no other bean of type `GreetingService` exists. (https://docs.spring.io/spring-boot/reference/features/developing-auto-configuration.html#features.developing-auto-configuration.condition-annotations.bean-conditions[see docs])

- Add the dependency to `com.workshop:auto-config` to `app`

âœ… What will happen when the application starts?

- Start the application and verify your assumption

- Now, remove the `MyGreetingService` class, or comment out/remove the `@Service` annotation on `MyGreetingService`.

âœ… What will happen when the application starts?

- Start the application and verify your assumption
====

==== Conclusion
Think for a moment, when is this useful and where does Spring Boot use this concept?

.Answer
[%collapsible]
====
Spring Boot's auto-configuration simplifies application development by automatically configuring components based on the dependencies present on the classpath. This feature reduces the need for manual setup, allowing developers to focus on business logic rather than boilerplate code.

For example, adding `spring-boot-starter-data-jpa` and a dependency to the `h2` database driver sets up a `DataSource` for an in-memory database without manual configuration.
====

==== Solution
[source,bash]
....
git checkout -f exercise-2
....

ðŸ¥³ Great, let's move on to the next exercise


=== Exercise 2: Custom Starter With Default GreetingService
You will now package the ``{auto-config}`Â´ and `{stdout}` modules into a reusable Spring Boot starter.

==== Learnings
- **How do spring-boot-starters work**

==== Task:
- Use the module `{starter}`
- Add dependencies to `{auto-config}` and `{stdout}`
- Replace direct dependencies in the `{app}` module with the new starter

âœ… Confirm that the app still works as expected and prints the greeting.

==== Detailed Steps

==== Conclusion
ðŸ¤” Why create a starter? When is it useful in teams or public libraries?

.Collapsible Answer
[%collapsible]
====
- Clean separation of concerns
- Reusability for teams or public Maven users
- Simplifies integration (just add one dependency)
====

ðŸ¥³ Awesome, letâ€™s move on to the next exercise

==== Solution
ðŸ¥³ Terrific, letâ€™s move on to the next exercise

=== Exercise 3: Make The Greeting Configurable
_Estimated time: ~10 Min._

You want to allow applications to configure the `GreetingService` without implementing it.

==== Learnings
- **How to parametrize auto-configured beans**

==== Task
- Find the `GreetingProperties` in the `{auto-config}` module.

- Annotate the GreetingProperties with `@ConfigurationProperties(prefix = "workshop.greeting")`

- Annotate the `GreetingAutoConfiguration` with `@EnableConfigurationProperties(GreetingProperties.class)`

- Use the property as constructor argument for the  `StdOutGreetingService`.

âœ… Run the application and see how the service is greeting now.

- Define the `workshop.greeting.text` property and set it to "Gude!" or any greeting you prefer.

âœ… Run the application and see how the service is greeting now.

==== Conclusion
When does this become handy?

.Answer
[%collapsible]
====
It allows configuring beans provided through auto-configuration and change their behaviour without the need to change the bean declaration itself.
====

==== Detailed Steps

.Detailed Steps
[%collapsible]
====
- Find the `GreetingProperties` in the `{auto-config}` module.

- Annotate the `GreetingProperties` with `@ConfigurationProperties(prefix = "workshop.greeting")`

- Annotate the `GreetingAutoConfiguration` with `@EnableConfigurationProperties(GreetingProperties.class)`

- Provide `GreetingProperties` as parameter to the bean declaration of `StdOutGreetingService`

- Provide the property as constructor argument for the  `StdOutGreetingService`.

âœ… Run the application and see how the service is greeting now.

- Define the `workshop.greeting.text` property and set it to "Gude!" or any greeting you prefer.

âœ… Run the application and see how the service is greeting now.
====

==== Solution
[source,bash]
....
git checkout exercise-3
....


=== Exercise 4: GreetingService Conditional On Property
_Estimated Time: ~10Min._

==== Learnings
- **How to make auto-configured beans depending on properties**

==== Task
- Provide an alternative `GreetingService` implementation `LoggerGreetingService` that uses a logging framework.

- Declare a new bean for this new service that lives in `library-slf4j`.

- Add a dependency to `com.workshop:library-slf4j` in the `{auto-config}` module.

- Use the `@ConditionalOnProperty` annotation to the new bean to allow the application to decide which service bean should be used by setting a property `workshop.greeting.type`.

âœ… Run the application - why does fail?

- Fix the issue.

- Now the application should be able to use `workshop.greeting.type=logger` or `workshop.greeting.type=stdout` to decide which service to use.

- Remove the property

âœ… Run the application - why does it start?

- define a property `workshop.greeting.type`


âœ… Run the application - why does fail?

- If no property is given it should be written to stdout.


==== Conclusion


==== Detailed Steps

.Detailed Steps
[%collapsible]
====
- Provide an alternative `GreetingService` implementation `LoggerGreetingService` that uses a logging framework.

- Add a dependency to `com.workshop:library-slf4j` in `{auto-config}`.

- Declare a new bean for `LoggerGreetingService` in `GreetingAutoConfiguration`.

- Add a dependency to `org.slf4j:slf4j-simple` in the `library-slf4j` module.

- Use the `@ConditionalOnProperty(name="workshop.greeting.type")` annotation to the new bean to allow the application to decide which service bean should be used by setting the property.

âœ… Run the application - why does it start?

- define a property `workshop.greeting.type`

âœ… Run the application - why does fail?

- To fix the issue add `@ConditionalOnProperty(name="workshop.greeting.type", havingValue="stdout")` to the `StdOutGreetingService` bean and add the attribute `havingValue = "logger"` to the `LoggerGreetingService` bean.

âœ… Run the application - why does it start?

- Now the application should be able to use `workshop.greeting.type=logger` or `workshop.greeting.type=stdout` to decide which service to use.

- Remove the property

âœ… Run the application - why does fail?

- If no property is given it should be written to stdout.

- Add the attribute `havingValue = "stdout"` to `StdOutGreetingService` bean.

âœ… Run the application - why does it start?
====


=== Exercise 5: Custom Starter Without Default GreetingService

=== Learnings
- **How to make auto-configured beans depending on classpath**

ðŸ¥³ Wicked, letâ€™s move on to the next exercise


=== Exercise 6: Using Custom Conditions

==== Learning
- **How to read the condition eva,utaion report**

=== Exercise 7: Using Custom Conditions

==== Learning
- **How to make autoconfigured beans depending on custom conditions**


It is also possible to provide custom conditions as equivalent to existing `@On...` conditions.
Let's create a custom condition that  checks a property `my.custom.condition`. Just because it's simple. But imagine you have a more sophisticated custom check here. (e.g. infrastructure checks)
https://docs.spring.io/spring-boot/reference/actuator/endpoints.html#actuator.endpoints.kubernetes-probes[see kubernetes-probes]
https://docs.spring.io/spring-boot/how-to/deployment/cloud.html#howto.deployment.cloud.kubernetes[cloud.kubernetes]
--> System Property (!!!)+
File, Date... ?

==== Task
Create a new annotation `@ConditionalOnCustomCondition`.
It must have target of type and method and a retention of runtime.
Also, add `@Conditional({OnCustomCondition.class})` to the annotation.
Create the `OnCustomCondition` which must extend from `@SpringCondition`.
Override the `getMatchOutcome`  method and use `ConditionOutcome.match(..)` and `noMatch(..)` respectively.
When your custom condition is true, a `BeepingGreetingService` should be used.

[[testing]]
=== Step X: Testing The Auto-Configuration
_Estimated time:  ~TODO-MH Min._

Create unit tests to ensure that the `GreetingAutoConfiguration` works as expected.

==== Task

- A test class for the `GreetingAutoConfiguration` class must be created.

- A dependency on `org.springframework.boot:spring-boot-starter-test` has to be added in the `auto-config` module.

- Spring Boot's `ApplicationContextRunner` should be used to test the auto-configuration.

- AssertJ assertions should be used to verify that the context contains a `StdOutGreetingService` bean if no property is set.

- The test should assert that the context contains a `StdOutGreetingService` bean if the property `workshop.greeting.type` is set to `stdout`.

- The test should assert that the context contains a `LoggerGreetingService` bean if the property `workshop.greeting.type` is set to `logger`.

- The test should assert that user-defined beans take precedence over the auto-configured `GreetingService` beans â€” essentially testing that `@ConditionalOnMissingBean` works.

==== Conclusion

What value has a unit test for an auto-configuration?

.Answer
[%collapsible]
====
Auto-configurations can contain a lot of conditions, sometimes even custom ones. As this auto-configuration is part of your codebase,
you should also unit-test it to ensure that it behaves as designed, same as the rest of your code.
Spring Boot's `ApplicationContextRunner` makes this easy.
====


==== Detailed Steps

.Detailed Steps
[%collapsible]
====

* Create a class named `GreetingAutoConfigurationTest` in `auto-config/src/test/java` in the package `com.workshop.magic.config`.

* Create a field of type `ApplicationContextRunner`, and use the fluent API to call `withConfiguration` with `AutoConfigurations.of(GreetingAutoConfiguration.class)`.

* Write a test case named `shouldProvideStdOutGreetingServiceByDefault` which uses the `run` method of the `ApplicationContextRunner` field.

** Inside the lambda block of the `run` method, use AssertJ's `assertThat` on the context to call `hasSingleBean` with an `StdOutGreetingService.class` argument.

* Write a test case named `shouldProvideStdOutGreetingServiceWhenPropertyIsSet` which uses the `withPropertyValues` of the `ApplicationContextRunner` field to set the property `workshop.greeting.type` to `stdout`.

** Inside the lambda block of the `run` method, use AssertJ's `assertThat` on the context to call `hasSingleBean` with an `StdOutGreetingService.class` argument.

* Write a test case named `shouldProvideLoggerGreetingServiceWhenPropertyIsSet` which uses the `withPropertyValues` of the `ApplicationContextRunner` field to set the property `workshop.greeting.type` to `logger`.

** Inside the lambda block of the `run` method, use AssertJ's `assertThat` on the context to call `hasSingleBean` with an `LoggerGreetingService.class` argument.

* Write a test case named `shouldBackOffIfGreetingServiceIsDefinedByUser` which uses the `withBean` method of the `ApplicationContextRunner` field to define a bean of type `GreetingService`.

** Inside the lambda block of the `run` method, use AssertJ's `assertThat` on the context to call `hasSingleBean` with an `GreetingService.class` argument.

====

==== Solution
[source,bash]
....
git checkout TODO-MH
....


[[properties-metadata]]
=== Step X: Adding properties metadata
_Estimated time:  ~TODO-MH Min._

Use the Spring Boot configuration processor to generate metadata for your configuration properties.

==== Task

- Add the `org.springframework.boot:spring-boot-configuration-processor` to your project

- Run a build and inspect the `components/library-autoconfigure/target/classes/META-INF/spring-configuration-metadata.json` file

ðŸ¤” Think about why that file could be useful

- The `text` property in `GreetingProperties`  should be renamed to `greeting`, while deprecating the `text` property. Use `@Deprecated` and `@DeprecatedConfigurationProperty` annotations to achieve this

- Run a build and inspect the file `spring-configuration-metadata.json` again

ðŸ¤” What has changed? Why could that be useful?

ðŸ¤” Open the `application.properties` in your IDE. Do you notice something?

- Add `org.springframework.boot:spring-boot-properties-migrator` to your app

- Start the app and observe the console output

==== Conclusion

What values is provided by that metadata file? Who could use it?

.Answer
[%collapsible]
====
This metadata file is read by IDEs to provide auto-completion for properties.
Additionally, deprecations and their replacement are also recorded in that file, which is also used by IDEs to guide users.
And the `spring-boot-properties-migrator` also uses this file to display deprecations on startup and to provide the automatic mapping from the old property to the new one.
====


==== Detailed Steps

.Detailed Steps
[%collapsible]
====

- Add `org.springframework.boot:spring-boot-configuration-processor` to `components/library-autoconfigure/pom.xml`, with `optional = true`.
- Configure the `maven-compiler-plugin` to include `org.springframework.boot:spring-boot-configuration-processor` as an annotation processor.
You can take a look at https://start.spring.io/#!type=maven-project&language=java&platformVersion=3.4.5&packaging=jar&jvmVersion=24&groupId=com.example&artifactId=demo&name=demo&description=Demo%20project%20for%20Spring%20Boot&packageName=com.example.demo&dependencies=configuration-processor[the POM file generated by start.spring.io] for an example.
- Run `./mvnw compile` and inspect `components/library-autoconfigure/target/classes/META-INF/spring-configuration-metadata.json`.
- Replace `private String text;` in the `GreetingProperties` class with `private String greeting`.
- Annotate the `public String getText()` method with `@Deprecated` and with `@DeprecatedConfigurationProperty(replacement = "workshop.greeting.greeting")`.
- Return `this.greeting` from the `getText()` method.
- Assign `this.greeting` in the `setText()` method.
- Add a new getter and setter method for `private String greeting`.
- Run `./mvnw compile` and inspect `components/library-autoconfigure/target/classes/META-INF/spring-configuration-metadata.json`.
- Add `org.springframework.boot:spring-boot-properties-migrator` with `scope = runtime` to `app/app/pom.xml`.
- Run the application

====

==== Solution
[source,bash]
....
git checkout TODO-MH
....

=== Step X: Build config
--> optional = true


=== Step 6: Order CUSTOM Auto-Configuration Beans
TODO

=== Step 7: Depend On Order of EXISTING Auto-Configuration Beans
TODO

--> ObjectMapper

- [ ] Moritz guggt mal nach einem gescheiten Beispiel
- [ ] Alternativ: Hinweis und keine Ãœbung

== Resources

=== Related Talk
https://2025.springio.net/sessions/demystifying-spring-boot-magic/

==== Reference
- https://docs.spring.io/spring-boot/reference/using/auto-configuration.html[Spring Boot Auto-configuration]
