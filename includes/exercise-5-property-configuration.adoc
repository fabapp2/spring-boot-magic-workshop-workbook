// tag::main[]
_Estimated Time: ~10Min._

==== Learnings
- **How to parametrize auto-configured beans**
- **How to make auto-configured beans depending on properties**

==== Task

. Make the alternative `GreetingService` implementation `LoggerGreetingService` available as auto-configured bean using properties.
. Add a new bean declaration for `LoggerGreetingService` in the auto-configuration class.
. Add a dependency to `{slf4j}` in the `{auto-config}` module.
. Annotate the new bean with a property-based condition to activate it only when `workshop.greeting.type=logger`.
. Annotate the existing bean for `StdOutGreetingService` to act as fallback when the property is `stdout` or not set.
. Provide a configuration class that binds properties with prefix `workshop.greeting`.
. Enable property binding for the configuration class in the auto-configuration class.
. Inject the bound configuration into both beans and pass the greeting text to the constructor.
. Add the following properties in `application.properties`:
    - `workshop.greeting.text`
    - `workshop.greeting.type`
. Start the application and observe which implementation is used.
. âœ… You should see: LoggerGreetingService: Gude SpringIO Barcelona
. Remove or change the `workshop.greeting.type` property and observe the fallback behavior.


==== Conclusion

In this exercise, you learned how to make auto-configured beans dynamic using external properties.
This allows developers to adapt behavior using simple property values, without needing custom profiles or bean overrides.

Using `@ConditionalOnProperty`, you can activate specific beans based on the application's configuration, enabling powerful runtime flexibility.

ðŸ¤” Why is this useful in real-world Spring Boot applications?

.Answer
[%collapsible]
====
It allows configuring beans provided through auto-configuration and changing their behavior without the need to change the bean declaration itself.
This enables teams to toggle functionality through properties, and provides sensible defaults with the ability to override them.
====

==== Detailed Steps


.Detailed Steps
[%collapsible]
====

. In the `{auto-config}` module, open the `GreetingProperties` class and annotate it with:
+
[source,java]
----
@ConfigurationProperties(prefix = "workshop.greeting")
----

. In the same module, annotate `GreetingAutoConfiguration` with:
+
[source,java]
----
@EnableConfigurationProperties(GreetingProperties.class)
----

. Add the optional dependency to `{slf4j}` in `{auto-config}/pom.xml`.

. In `GreetingAutoConfiguration`, inject `GreetingProperties` into both `GreetingService` bean methods.

. Replace the constructor calls with:
+
[source,java]
----
new StdOutGreetingService(properties.getText())
new LoggerGreetingService(properties.getText())
----

. Annotate the `StdOutGreetingService` bean method with:
+
[source,java]
----
@ConditionalOnProperty(prefix = "workshop.greeting", name = "type", havingValue = "stdout", matchIfMissing = true)
----

. Annotate the `LoggerGreetingService` bean method with:
+
[source,java]
----
@ConditionalOnProperty(prefix = "workshop.greeting", name = "type", havingValue = "logger")
----

. In `application.properties` set the following:
+
[source,properties]
----
workshop.greeting.type=logger
workshop.greeting.text=Gude!
----

. Run the application.

. âœ… You should see: _LoggerGreetingService: Gude SpringIO Barcelona_

. Remove the `workshop.greeting.type` line and restart the app.
+
TIP: If you don't see the logger-based output, double-check that `library-slf4j` is included in the app module and that the property `type=logger` is set.

. âœ… You should now see: _StdOutGreetingService: Gude SpringIO Barcelona_

TIP: The `LoggerGreetingService` bean will only be created if `library-slf4j` is on the classpath. If not, even `type=logger` will not work.
====

==== Solution
[source,bash]
....
git checkout -f exercise-6
....

ðŸ¥³ Superb, let's move on to the next exercise
// end::main[]